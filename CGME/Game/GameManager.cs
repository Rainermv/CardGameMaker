//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.544
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace CGME
{
	public class GameManager
	{
		// PRIVATE VARIABLES ----------------------------------------
		private static int ID;
		private static CGME.GameManager instance = null;

		private CGME.Game game =  null;
		private CGLibrary library = null;

		//private CGME.Ruleset running_ruleset = null;
		private CGME.Phase running_phase = null;
		
		private List<IEngineListener> engine_listeners = new List<IEngineListener>();
		private List<IActionEventListener> action_listeners = new List<IActionEventListener>();
		
		private List<Actor> selection_buffer = new List<Actor>();

		// CONSTRUCTORS ----------------------------------------

		private GameManager ()
		{
			Debug.Log ("Game Manager instantiated");
		}

		// GET/SET FUNCTIONS ----------------------------------------
		
		public CGLibrary Library{
			get {return library;}
			set {library = value;}
		}
		
		public void AddEngineListener(IEngineListener list){
			engine_listeners.Add (list);
		}
		
		public void AddActionEventListener(IActionEventListener list){
			action_listeners.Add (list);
		}
		
		public static CGME.GameManager GetInstance(){
			if (instance == null)
				instance = new GameManager();
			
			return instance;
			
		}
		
		public void SetGame(Game g){
			this.game = g;
		}
		
		public Game GetGame(){
			return this.game;
		}

		public CGME.Phase Running_phase{
			get{return running_phase;}
		}

//		public int Phase_Controller{
//			get{return phase_controller;}
//			set{phase_controller = value;}
//		}

		// PRIVATE FUNCTIONS -----------------------------------------

//		
		// End phase
		private void EndPhase()
		{
			running_phase.End();			
		}
		
		// End phase and call next phase
		private void NextPhase()
		{
			running_phase = game.NextPhase();
			InitPhase();
//			
		}
		
		private void SetPhase(int index){
			running_phase = game.GetPhase(index);
			InitPhase();
		}
		
		private void InitPhase(){
			running_phase.Init ();
			Debug.Log ("Initiating Phase - " + running_phase.CGType);
		}

		// PUBLIC FUNCTIONS ------------------------------------------
		public bool Start() // inicia os parametros do jogo
		{
			Debug.Log("GM start");
			//game = GameBuilder.Build();

			if (game == null){
				Debug.Log("Error - game failed to load");
				return false;
			}
			
			game.Enable (true);
			game.Start ();
			
			//DebugComponents();
			
			SetPhase (0);
			//running_phase = game.GetPhase(0);
			//if (!DefinePhase(game.GetPhase(0))) // play the first phase by default
				//return false;
		
			return true;
		}

	
		public void Update() // atualiza o jogo
		{
			
			running_phase.Run ();
			
			if (running_phase.IsFinished)
				NextPhase ();

		}


		public CGObject CommandFindObject(string type){
			return game.FindObject(type);
		}

		public bool CommandTransferObject(Actor source, Actor destination){
			
			(source.Parent as Actor).RemoveChild(source);
			
			if (destination.AddChild(source) == null) return false;
						
			DispatchEvent(EngineEvent.TransferChild, source, destination);
			
			return true;
		
		}

		public void CommandEndGame() // finaliza o jogo
		{
			Debug.Log ("ENDING GAME");
			Application.Quit();
		}
		
		public void CommandEndPhase(){
			EndPhase();
		}
		
		public void CommandCustomAction(CustomActionEvent action, CGObject source, CGObject param1, CGObject param2){
			DispatchCustomAction(action, source, param1, param2);
		}
		
		// SELECTION BUFFER
		
		public int CommmandBufferGetSize(){
			return selection_buffer.Count;
		}
		
		public void CommandBufferPushSelection(Actor obj){
			selection_buffer.Add(obj);
			obj.DispatchEvent(EngineEvent.BufferSelect,null,null);
		}
		
		public Actor CommandBufferPopSelection(){
			if (selection_buffer.Count > 0){
				
				Actor return_value = selection_buffer[selection_buffer.Count-1];
				selection_buffer.Remove (return_value);
				
				return_value.DispatchEvent(EngineEvent.BufferRemove,null,null);
				
				return return_value;
			
			}
			return null;
		}
		
		public Actor CommandBufferGetFromSelection(int index){
			if (selection_buffer.Count > index){
				return selection_buffer[index];
			}
			return null;
		}
		
		public void CommandBufferRemoveFromSelection(Actor act){
			selection_buffer.Remove(act);
			act.DispatchEvent(EngineEvent.BufferRemove,null,null);
		}
		
		public void CommandBufferClear(){
			foreach (Actor act in selection_buffer)
				act.DispatchEvent(EngineEvent.BufferRemove,null,null);
			selection_buffer.Clear();
		}
		
		// OTHER USELESS CRAP
		
		public void AddAction(Action action, string phase){
		
			game.GetPhase(phase).AddAction(action)	;		
		}
		
		public void RemoveAction(Action action, string phase){
		
			game.GetPhase(phase).RemoveAction(action);
		}
		
		// Request a unique ID
		public static int NewId(){
			return ID++;
		}
		
		protected void DispatchEvent(EngineEvent ee, CGObject param1, CGObject param2){
			foreach (IEngineListener listener in engine_listeners){
				listener.Act(ee, null, param1, param2);
			}
		}
		
		private void DispatchCustomAction(CustomActionEvent action, CGObject source, CGObject param1, CGObject param2){
			foreach (IActionEventListener listener in action_listeners){
				listener.ActEvent(action, source, param1, param2);
			}
		}

		// TEMP FUNCTIONS -----------------------------------

		public bool SpacePress(){
			if (Input.GetKeyDown("e"))
				return true;
			return false;
		}

		public static void DebugLog(string log)
		{
			Debug.Log(log);
		}
		
		public void DebugComponents(){
		
			for (int rule_index = 0; rule_index < game.Phases_Size; rule_index++){ // FOR EACH PHASE
				
				CGME.Phase phase = game.GetPhase(rule_index);
				Debug.Log ("(ID:" + phase.Id + ") " + " -----PHASE: " + phase.CGType + DebugRes(phase));
				
				for (int phase_index = 0; phase_index < phase.Actions_Size; phase_index++) {// FOR EACH ACTION
					
					CGME.Action action = phase.GetAction(phase_index);
					Debug.Log ("(ID:" + action.Id + ") "  + "-------------ACTION:" + action.CGType);// + DebugRes(action));
				}
				
			}
			
			for (int game_index = 0; game_index < game.Players_Size; game_index++){ // FOR EACH PLAYER
				
				CGME.Player player = game.GetPlayer (game_index);
				Debug.Log ("(ID:" + player.Id + ") "  + "PLAYER: " + player.CGType + DebugRes(player));
				
				for (int player_index = 0; player_index < player.Decks_Size; player_index++){ // FOR EACH DECK
					
					CGME.Deck deck = player.GetDeck(player_index);
					Debug.Log ("(ID:" + deck.Id + ") " + "------DECK: " + deck.CGType + DebugRes(deck));
					
					for (int deck_index = 0; deck_index < deck.Cards_Size; deck_index++) {// FOR EACH CARD
						
						CGME.Card card = deck.GetCard(deck_index);
						Debug.Log ("(ID:" + card.Id + ") " + "--------------CARD:" + card.CGType + DebugRes(card));
						
					}
				}
			}
			
		}

		public static string DebugRes(CGME.Actor actor){
			string log = "";
			if (actor.Resources_Size > 0){
				log = "|| Resources: ";
				foreach (CGME.Resource resource in actor.Resources){
					log += ("(ID:" + resource.Id + ") "  + ": " + resource.ToString() + " :: ");
//				
				}

			}
			return log;
		}
	}
}

