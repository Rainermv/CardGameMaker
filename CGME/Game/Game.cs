//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.544
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace CGME
{
	[Serializable]
	public class Game : CGObject
	{
		// PRIVATE VARIABLES -----------------------------------------------------
		//private List<CGME.Ruleset> rulesets = new List<CGME.Ruleset>();
		//private Ruleset
		public List<CGME.Phase> phases = new List<CGME.Phase>();
		public List<CGME.Player> players = new List<CGME.Player>();
		
		private int phase_iterator = 0;
		
		public int PhaseIterator{
			get{return phase_iterator;}
			set{phase_iterator = value;}
		}
			

		// CONSTRUCTORS -----------------------------------------------------------

		public Game ()
		{
			cgtype = "New Game Ruleset";

		}
	
		// GET/SET FUNCTIONS -----------------------------------------------------
		
		// LISTENERS
		
		

		// PHASES ---------------
		
		public Phase GetPhase(CGME.Phase _phase){
			
			foreach (Phase phase in phases) {
				if (phase == _phase)
					return phase;
			}
			
			return null;
		}
		
		public Phase GetPhase(string name){
			foreach (Phase phase in phases) {
				if (phase.CGType == name)
					return phase;
			}
			
			return null;
		}
		
		public Phase GetPhase(int index){
			if (index < phases.Count){
				phase_iterator = index;
				return phases[index];
				}
			return null;
		}
		
		public int Phases_Size{
			get { return phases.Count;}
		}
		
		// PLAYERS -----------------

		public Player GetPlayer(CGME.Player _player){
			
			foreach (Player player in players) {
				if (player == _player)
					return player;
			}
			
			return null;
		}
		
		public Player GetPlayer(string name){
			foreach (Player player in players) {
				//CGME.GameManager.DebugLog("DEBUG - GET PLAYER, NAME == "+ player.Name);
				if (player.CGType == name)
					return player;
			}
			
			return null;
		}

		public Player GetPlayer(int index){
			return players[index];
		}
		
		public int Players_Size{
			get { return players.Count;}
		}

		// LIST FUNCTIONS --------------------------------------------------------

		// PHASES --------------
		
		public Phase AddPhase(CGME.Phase new_phase){
			DispatchEvent(EngineEvent.AddChild, new_phase, null);
			
			new_phase.Index = phases.Count;
			
			phases.Add(new_phase);
			
			new_phase.Parent = this;
			
			
			return new_phase;
			
		}
		
		public void RemovePhase(CGME.Phase phase){
			phases.Remove(phase);
		}
		
		public void RemovePhase(int index){
			phases.RemoveAt(index);
		}
		
		public void ClearPhases(){
			phases.Clear();
		}

		// PLAYERS --------------
		public CGME.Player AddPlayer(CGME.Player new_player){
			DispatchEvent(EngineEvent.AddChild, new_player, null);
			players.Add(new_player);
			
			new_player.Parent = this;
			
			return new_player;
		}
		
//		public CGME.Player AddPlayer(string name){
//			Player new_player = new Player();
//			players.Add(new_player);
//			return new_player;
//		}
		
		public void RemovePlayer(CGME.Player player){
			players.Remove(player);
		}
		
		public void RemovePlayer(int index){
			players.RemoveAt(index);
		}
				
		public void ClearPlayers(){
			players.Clear();
		}

		// PUBLIC FUNCTIONS
		
		private void Iterate(){
			
			PhaseIterator++;  // go to next phase
			GameManager.DebugLog (PhaseIterator.ToString());
			if (PhaseIterator >= Phases_Size)
				PhaseIterator = 0;  // go to phase zero
			
		}
		
		public CGME.Phase NextPhase(){

			Iterate();
			CGME.Phase phase = GetPhase(PhaseIterator);
			return phase;
			
		}
		
		public void AddResource (Resource resource, string target){
		
			//GameManager.DebugLog("Game add resource to" + " :: " + target);
			//TODO fix this.....
			Actor actor = (Actor)FindObject(target);
			
			if (actor != null) {
				actor.AddResource(resource);
				
				GameManager.DebugLog ("Adding " + resource.CGType + " to " + actor.CGType);
			}
		}
		
		public override CGObject FindObject(int id){
			return null;
		}
		
		public override CGObject FindObject(string name){
		
			//GameManager.DebugLog("Game find 1" + " :: " + actor_name);
		
			foreach (CGObject obj in phases){
				CGObject found = obj.FindObject(name);
				if (found != null) return found;
			}
			foreach (CGObject obj in players){
				CGObject found = obj.FindObject(name);
				if (found != null) return found;
			}
			
			return null;
		}
		
		public override void Enable(bool enable){
		
			//this.enabled = enable;
		
			foreach (Player player in players){
				player.Enable(enable);
			}
			foreach (Phase phase in phases){
				phase.Enable(enable);
			}
		}
		
		public override void Start(){
			foreach (Player player in players){
				player.Start();
			}
			foreach (Phase phase in phases){
				phase.Start();
			}
		}
		
		public override void ClearChildren(){
			players.Clear();
			phases.Clear();
		}
		public override void CleanupChildren(){
			for (int i = 0; i < players.Count; i++){
				if (players[i].DestroyFlag){
					players.RemoveAt(i);
					break;
				}
			}
			for (int i = 0; i < phases.Count; i++){
				if (phases[i].DestroyFlag){
					phases.RemoveAt(i);
					break;
				}
			}
		}
	}

	
}

